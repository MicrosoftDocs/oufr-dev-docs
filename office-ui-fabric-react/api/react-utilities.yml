### YamlMime:TSPackage
uid: '@fluentui/react-utilities!'
name: '@fluentui/react-utilities'
type: package
summary: ''
interfaces:
  - '@fluentui/react-utilities!BaseSlots:interface'
  - '@fluentui/react-utilities!ComponentProps:interface'
  - '@fluentui/react-utilities!UseBooleanCallbacks:interface'
functions:
  - name: 'getNativeElementProps(tagName, props, excludedPropNames)'
    uid: '@fluentui/react-utilities!getNativeElementProps:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Given an element tagname and user props, filters the props to only allowed
      props for the given element type.
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function getNativeElementProps<TAttributes extends
        React.HTMLAttributes<any>>(tagName: string, props: {},
        excludedPropNames?: string[]): TAttributes;
      parameters:
        - id: tagName
          description: Tag name (e.g. "div")
          type: string
        - id: props
          description: Props object
          type: '{}'
        - id: excludedPropNames
          description: List of props to disallow
          type: 'string[]'
      return:
        type: TAttributes
        description: ''
  - name: 'getNativeProps(props, allowedPropNames, excludedPropNames)'
    uid: '@fluentui/react-utilities!getNativeProps:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Gets native supported props for an html element provided the allowance
      set. Use one of the property sets defined (divProperties, buttonPropertes,
      etc) to filter out supported properties from a given props set. Note that
      all data- and aria- prefixed attributes will be allowed. NOTE:
      getNativeProps should always be applied first when adding props to a react
      component. The non-native props should be applied second. This will
      prevent getNativeProps from overriding your custom props. For example, if
      props passed to getNativeProps has an onClick function and getNativeProps
      is added to the component after an onClick function is added, then the
      getNativeProps onClick will override it.
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function getNativeProps<T extends Record<string,
        any>>(props: Record<string, any>, allowedPropNames: string[] |
        Record<string, number>, excludedPropNames?: string[]): T;
      parameters:
        - id: props
          description: The unfiltered input props
          type: 'Record&lt;string, any&gt;'
        - id: allowedPropNames
          description: ''
          type: 'string[] | Record&lt;string, number&gt;'
        - id: excludedPropNames
          description: ''
          type: 'string[]'
      return:
        type: T
        description: The filtered props
  - name: 'omit(obj, exclusions)'
    uid: '@fluentui/react-utilities!omit:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Tiny helper to do the minimal amount of work in duplicating an object but
      omitting some props. This ends up faster than using object ...rest or
      reduce to filter.


      This behaves very much like filteredAssign, but does not merge many
      objects together, uses an exclusion object map, and avoids spreads all for
      optimal performance.


      See perf test for background: https://jsperf.com/omit-vs-rest-vs-reduce/1
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function omit<TObj extends Record<string, any>>(obj:
        TObj, exclusions: (keyof TObj)[]): TObj;
      parameters:
        - id: obj
          description: The object to clone
          type: TObj
        - id: exclusions
          description: The array of keys to exclude
          type: '(keyof TObj)[]'
      return:
        type: TObj
        description: ''
  - name: useBoolean(initialState)
    uid: '@fluentui/react-utilities!useBoolean:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Hook to store a value and generate callbacks for setting the value to true
      or false. The identity of the callbacks will always stay the same.
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function useBoolean(initialState: boolean): [boolean,
        UseBooleanCallbacks];
      parameters:
        - id: initialState
          description: Initial value
          type: boolean
      return:
        type: '[boolean, UseBooleanCallbacks]'
        description: >-
          Array with the current value and an object containing the updater
          callbacks.
  - name: useConst(initialValue)
    uid: '@fluentui/react-utilities!useConst:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Hook to initialize and return a constant value. Unlike `React.useMemo`<!--
      -->, this is guaranteed to always return the same value (and if the
      initializer is a function, only call it once). This is similar to setting
      a private member in a class constructor.


      If the value should ever change based on dependencies, use `React.useMemo`
      instead.
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: 'export declare function useConst<T>(initialValue: T | (() => T)): T;'
      parameters:
        - id: initialValue
          description: >-
            Initial value, or function to get the initial value. Similar to
            `useState`<!-- -->, only the value/function passed in the first time
            this is called is respected.
          type: T | (() =&gt; T)
      return:
        type: T
        description: The value. The identity of this value will always be the same.
  - name: 'useControllableValue(controlledValue, defaultUncontrolledValue)'
    uid: '@fluentui/react-utilities!useControllableValue:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Hook to manage a value that could be either controlled or uncontrolled,
      such as a checked state or text box string.
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function useControllableValue<TValue, TElement extends
        HTMLElement>(controlledValue: TValue | undefined,
        defaultUncontrolledValue: TValue | undefined): Readonly<[TValue |
        undefined, (update: React.SetStateAction<TValue | undefined>) => void]>;
      parameters:
        - id: controlledValue
          description: >-
            The controlled value passed in the props. This value will always be
            used if provided, and the internal state will be updated to reflect
            it.
          type: TValue | undefined
        - id: defaultUncontrolledValue
          description: Initial value for the internal state in the uncontrolled case.
          type: TValue | undefined
      return:
        type: >-
          Readonly&lt;[TValue | undefined, (update:
          React.SetStateAction&lt;TValue | undefined&gt;) =&gt; void]&gt;
        description: >-
          An array of the current value and an updater callback. Like
          `React.useState`<!-- -->, the updater callback always has the same
          identity, and it can take either a new value, or a function which is
          passed the previous value and returns the new value. 
          https://reactjs.org/docs/uncontrolled-components.html
  - name: 'useControllableValue(controlledValue, defaultUncontrolledValue, onChange)'
    uid: '@fluentui/react-utilities!useControllableValue:function(2)'
    package: '@fluentui/react-utilities!'
    summary: ''
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function useControllableValue<TValue, TElement extends
        HTMLElement, TEvent extends React.SyntheticEvent<TElement> |
        undefined>(controlledValue: TValue | undefined,
        defaultUncontrolledValue: TValue | undefined, onChange:
        ChangeCallback<TElement, TValue, TEvent> | undefined): Readonly<[TValue
        | undefined, (update: React.SetStateAction<TValue | undefined>, ev?:
        React.FormEvent<TElement>) => void]>;
      parameters:
        - id: controlledValue
          description: ''
          type: TValue | undefined
        - id: defaultUncontrolledValue
          description: ''
          type: TValue | undefined
        - id: onChange
          description: ''
          type: 'ChangeCallback&lt;TElement, TValue, TEvent&gt; | undefined'
      return:
        type: >-
          Readonly&lt;[TValue | undefined, (update:
          React.SetStateAction&lt;TValue | undefined&gt;, ev?:
          React.FormEvent&lt;TElement&gt;) =&gt; void]&gt;
        description: ''
  - name: 'useId(prefix, providedId)'
    uid: '@fluentui/react-utilities!useId:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      Hook to generate a unique ID in the global scope (spanning across
      duplicate copies of the same library).
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function useId(prefix?: string, providedId?: string):
        string;
      parameters:
        - id: prefix
          description: Optional prefix for the ID
          type: string
        - id: providedId
          description: >-
            Optional id provided by a parent component. Defaults to the provided
            value if present, without conditioning the hook call
          type: string
      return:
        type: string
        description: The ID
  - name: useMergedRefs(refs)
    uid: '@fluentui/react-utilities!useMergedRefs:function(1)'
    package: '@fluentui/react-utilities!'
    summary: >-
      React hook to merge multiple React refs (either MutableRefObjects or ref
      callbacks) into a single ref callback that updates all provided refs
    remarks: ''
    isPreview: false
    isDeprecated: false
    syntax:
      content: >-
        export declare function useMergedRefs<T>(...refs: (React.Ref<T> |
        undefined)[]): RefObjectFunction<T>;
      parameters:
        - id: refs
          description: Refs to collectively update with one ref value.
          type: '(React.Ref&lt;T&gt; | undefined)[]'
      return:
        type: RefObjectFunction&lt;T&gt;
        description: >-
          A function with an attached "current" prop, so that it can be treated
          like a RefObject.
